CMSC 427 Computer Graphics1
David M. Mount Department of Computer Science University of Maryland Spring 2004

Lecture 5: Drawing in OpenGL: Transformations
Reading: Transformation are discussed (for 3-space) in Chapter 5. Two dimensional projections and the viewport transformation are discussed at the start of Chapter 6. For reference documentation, visit the OpenGL documentation links on the course web page.
More about Drawing: So far we have discussed how to draw simple 2-dimensional objects using OpenGL. Suppose that we want to draw more complex scenes. For example, we want to draw objects that move and rotate or to change the projection. We could do this by computing (ourselves) the coordinates of the transformed vertices. However, this would be inconvenient for us. It would also be inef?cient, since we would need to retransmit all the vertices of these objects to the display processor with each redrawing cycle, making it impossible for the display processor to cache recently processed vertices. For this reason, OpenGL provides tools to handle transformations. Today we consider how this is done in 2-space. This will form a foundation for the more complex transformations, which will be needed for 3-dimensional viewing.
Transformations: Linear and af?ne transformations are central to computer graphics. Recall from your linear algebra class that a linear transformation is a mapping in a vector space that preserves linear combinations. Such transformations include rotations, scalings, shearings (which stretch rectangles into parallelograms), and combinations thereof. Af?ne transformations are somewhat more general, and include translations. We will discuss af?ne transformations in detail in a later lecture. The important features of both transformations is that they map straight lines to straight lines, they preserve parallelism, and they can be implemented through matrix multiplication. They arise in various ways in graphics.
Moving Objects: from frame to frame in an animation. Change of Coordinates: which is used when objects that are stored relative to one reference frame are to be accessed in a different reference frame. One important case of this is that of mapping objects stored in a standard coordinate system to a coordinate system that is associated with the camera (or viewer).
Lecture Notes 20 CMSC 427
Projection: is used to project objects from the idealized drawing window to the viewport, and mapping the viewport to the graphics display window. (We shall see that perspective projection transformations are more general than af?ne transformations, since they may not preserve parallelism.)
Mapping: between surfaces, for example, transformations that indicate how textures are to be wrapped around objects, as part of texture mapping.
OpenGL has a very particular model for how transformations are performed. Recall that when drawing, it was convenient for us to ?rst de?ne the drawing attributes (such as color) and then draw a number of objects using that attribute. OpenGL uses much the same model with transformations. You specify a transformation, and then this transformation is automatically applied to every object that is drawn, until the transformation is set again. It is important to keep this in mind, because it implies that you must always set the transformation prior to issuing drawing commands.
Because transformations are used for different purposes, OpenGL maintains three sets of matrices for performing various transformation operations. These are:
Modelview matrix: Used for transforming objects in the scene and for changing the coordinates into a form that is easier for OpenGL to deal with. (It is used for the ?rst two tasks above).
Projection matrix: Handles parallel and perspective projections. (Used for the third task above.)
Texture matrix: This is used in specifying how textures are mapped onto objects. (Used for the last task above.)
We will discuss the texture matrix later in the semester, when we talk about texture mapping. There is one more transformation that is not handled by these matrices. This is the transformation that maps the viewport to the display. It is set by glViewport().
Understanding how OpenGL maintains and manipulates transformations through these matrices is central to understanding how OpenGL works. This is not merely a "design consideration," since most display processors maintain such a set of matrices in hardware.
For each matrix type, OpenGL maintains a stack of matrices. The current matrix is the one on the top of the stack. It is the matrix that is being applied at any given time. The stack mechanism allows you to save the current matrix (by pushing the stack down) and restoring it later (by popping the stack). We will discuss the entire process of implementing af?ne and projection transformations later in the semester. For now, we'll give just basic information on OpenGL's approach to handling matrices and transformations.
OpenGL has a number of commands for handling matrices. In order to know which matrix (Modelview, Projection, or Texture) to which an operation applies, you can set the current matrix mode. This is done with the following command
glMatrixMode(h mode i); wherehmodeiis either GL MODELVIEW, GL PROJECTION, orGL TEXTURE. The default mode is GL MODELVIEW. GL MODELVIEW is by far the most common mode, the convention in OpenGL programs is to assume that you are always in this mode. If you want to modify the mode for some reason, you ?rst change the mode to the desired mode (GL PROJECTION or GL TEXTURE), perform whatever operations you want, and then immediately change the mode back to GL MODELVIEW.
Once the matrix mode is set, you can perform various operations to the stack. OpenGL has an unintuitive way of handling the stack. Note that most operations below (except glPushMatrix()) alter the contents of the matrix at the top of the stack.
glLoadIdentity(): Sets the current matrix to the identity matrix.
glLoadMatrix*(M): Loads (copies) a given matrix over the current matrix. (The '*' can be either 'f' or 'd' depending on whether the elements of M are GL?oat or GLdouble, respectively.)
