CMSC 427 Computer Graphics1
David M. Mount Department of Computer Science University of Maryland Spring 2004

Lecture 3: Drawing in OpenGL: GLUT
Reading: Chapter 2 in Hearn and Baker. Detailed documentation on GLUT can be downloaded from the GLUT home page http://www.opengl.org/resources/libraries/glut.html.
The OpenGL API: Today we will begin discussion of using OpenGL, and its related libraries, GLU (which stands for the OpenGL utility library) and GLUT (an OpenGL Utility Toolkit). OpenGL is designed to be a machineindependent graphics library, but one that can take advantage of the structure of typical hardware accelerators for computer graphics.
The Main Program: Before discussing how to actually draw shapes, we will begin with the basic elements of how to create a window. OpenGL was intentionally designed to be independent of any speci?c window system. Consequently, a number of the basic window operations are not provided. For this reason, a separate library, called GLUT or OpenGL Utility Toolkit, was created to provide these functions. It is the GLUT toolkit which provides the necessary tools for requesting that windows be created and providing interaction with I/O devices.
Let us begin by considering a typical main program. Throughout, we will assume that programming is done in C++. Do not worry for now if you do not understand the meanings of the various calls. Later we will discuss the various elements in more detail. This program creates a window that is 400 pixels wide and 300 pixels high, located in the upper left corner of the display.
Typical OpenGL/GLUT Main Program int main(int argc, char** argv) // program arguments { glutInit(&argc, argv); // initialize glut and gl // double buffering and RGB glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB); glutInitWindowSize(400, 300); // initial window size glutInitWindowPosition(0, 0); // initial window position glutCreateWindow(argv[0]); // create window
...initialize callbacks here (described below)...
myInit(); // your own initializations glutMainLoop(); // turn control over to glut return 0; // (make the compiler happy)
}
Here is an explanation of the ?rst ?ve function calls.
glutInit(): The arguments given to the main program (argc and argv) are the command-line arguments supplied to the program. This assumes a typical Unix environment, in which the program is invoked from a command line. We pass these into the main initialization procedure, glutInit(). This procedure must be called before any others. It processes (and removes) command-line arguments that may be of interest to GLUT and the window system and does general initialization of GLUT and OpenGL. Any remaining arguments are then left for the user's program to interpret, if desired.
glutInitDisplayMode(): The next procedure, glutInitDisplayMode(), performs initializations informing OpenGL how to set up its frame buffer. Recall that the frame buffer is a special 2-dimensional array in main memory where the graphical image is stored. OpenGL maintains an enhanced version of the frame buffer with additional information. For example, this include depth information for hidden surface removal. The system needs to know how we are representing colors of our general needs in order to determine the depth (number of bits) to assign for each pixel in the frame buffer. The argument to glutInitDisplayMode() is a logical-or (using the operator "-") of a number of possible options, which are given in Table 1.
Lecture Notes 9 CMSC 427
Display Mode Meaning GLUT RGB Use RGB colors GLUT RGBA Use RGB plus a (for transparency) GLUT INDEX Use colormapped colors (not recommended) GLUT DOUBLE Use double buffering (recommended) GLUT SINGLE Use single buffering (not recommended) GLUT DEPTH Use depth buffer (needed for hidden surface removal)
Table 1: Arguments to glutInitDisplayMode().
.
Color: First off, we need to tell the system how colors will be represented. There are three methods, of which two are fairly commonly used: GLUT RGB or GLUT RGBA. The ?rst uses standard RGB colors (24-bit color, consisting of 8 bits of red, green, and blue), and is the default. The second requests RGBA coloring. In this color system there is a fourth component (A or a), which indicates the opaqueness of the color (1 = fully opaque, 0 = fully transparent). This is useful in creating transparent effects. We will discuss how this is applied later this semester. Single or Double Buffering: The next option speci?es whether single or double buffering is to be used, GLUT SINGLE or GLUT DOUBLE, respectively. To explain the difference, we need to understand a bit more about how the frame buffer works. In raster graphics systems, whatever is written to the frame buffer is immediately transferred to the display. (Recall this from Lecture 2.) This process is repeated frequently, say 30-60 times a second. To do this, the typical approach is to ?rst erase the old contents by setting all the pixels to some background color, say black. After this, the new contents are drawn. However, even though it might happen very fast, the process of setting the image to black and then redrawing everything produces a noticeable ?icker in the image. Double buffering is a method to eliminate this ?icker. In double buffering, the system maintains two separate frame buffers. The front buffer is the one which is displayed, and the back buffer is the other one. Drawing is always done to the back buffer. Then to update the image, the system simply swaps the two buffers. The swapping process is very fast, and appears to happen instantaneously (with no ?icker). Double buffering requires twice the buffer space as single buffering, but since memory is relatively cheap these days, it is the preferred method for interactive graphics. Depth Buffer: One other option that we will need later with 3-dimensional graphics will be hidden surface removal. This fastest and easiest (but most space-consuming) way to do this is with a special array called a depth buffer. We will discuss in greater detail later, but intuitively this is a 2-dimensional array which stores the distance (or depth) of each pixel from the viewer. This makes it possible to determine which surfaces are closest, and hence visible, and which are farther, and hence hidden. The depth buffer is enabled with the option GLUT DEPTH. For this program it is not needed, and so has been omitted. glutInitWindowSize(): This command speci?es the desired width and height of the graphics window. The general form is glutInitWindowSize(int width, int height). The values are given in numbers of pixels. glutInitPosition(): This command speci?es the location of the upper left corner of the graphics window. The form is glutInitWindowPosition(int x, int y) where the (x,y) coordinates are given relative to the upper left corner of the display. Thus, the arguments (0,0) places the window in the upper left corner of the display. Note that glutInitWindowSize() and glutInitWindowPosition() are both considered to be only suggestions to the system as to how to where to place the graphics window. Depending on the window system's policies, and the size of the display, it may not honor these requests. glutCreateWindow(): This command actually creates the graphics window. The general form of the command is glutCreateWindowchar(*title), where title is a character string. Each window has a title, and the argument is a string which speci?es the window's title. We pass in argv[0]. In Unix argv[0] is the name of the program (the executable ?le name) so our graphics window's name is the same as the name of our program.
Lecture Notes 10 CMSC 427
Note that glutCreateWindow() does not really create the window, but rather sends a request to the system that the window be created. Thus, it is not possible to start sending output to the window, until noti?cation has been received that this window is ?nished its creation. This is done by a display event callback, which we describe below.
Event-driven Programming and Callbacks: Virtually all interactive graphics programs are event driven. Unlike traditional programs that read from a standard input ?le, a graphics program must be prepared at any time for input from any number of sources, including the mouse, or keyboard, or other graphics devises such as trackballs and joysticks.
In OpenGL this is done through the use of callbacks. The graphics program instructs the system to invoke a particular procedure whenever an event of interest occurs, say, the mouse button is clicked. The graphics program indicates its interest, or registers, for various events. This involves telling the window system which event type you are interested in, and passing it the name of a procedure you have written to handle the event.
Types of Callbacks: Callbacks are used for two purposes, user input events and system events. User input events include things such as mouse clicks, the motion of the mouse (without clicking) also called passive motion, keyboard hits. Note that your program is only signaled about events that happen to your window. For example, entering text into another window's dialogue box will not generate a keyboard event for your program.
There are a number of different events that are generated by the system. There is one such special event that every OpenGL program must handle, called a display event. A display event is invoked when the system senses that the contents of the window need to be redisplayed, either because: • the graphics window has completed its initial creation, • an obscuring window has moved away, thus revealing all or part of the graphics window, • the program explicitly requests redrawing, by calling glutPostRedisplay(). Recall from above that the command glutCreateWindow() does not actually create the window, but merely requests that creation be started. In order to inform your program that the creation has completed, the system generates a display event. This is how you know that you can now start drawing into the graphics window.
Another type of system event is a reshape event. This happens whenever the window's size is altered. The callback provides information on the new size of the window. Recall that your initial call to glutInitWindowSize() is only taken as a suggestion of the actual window size. When the system 
