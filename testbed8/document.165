An a of 1 therefore would describe a linked list as balanced, whereas an a of 0.5 would only match almost complete binary trees.
A binary search tree that is a-weight-balanced must also be a-height-balanced, that is
height(tree) <= log1/a(NodeCount) + 1
Scapegoat trees are not guaranteed to keep a-weight-balance at all times, but are always loosely a-height-balanced in that
height(scapegoat tree) <= log1/a(NodeCount) + 1
This makes scapegoat trees similar to red-black trees in that they both have restrictions on their height. They differ greatly though in their implementations of determining where the rotations (or in the case of scapegoat trees, rebalances) take place. Whereas red-black trees store additional 'color' information in each node to determine the location, scapegoat trees find a scapegoat which isn't a-weight-balanced to perform the rebalance operation on. This is loosely similar to AVL trees, in that the actual rotations depend on 'balances' of nodes, but the means of determining the balance differs greatly. Since AVL trees check the balance value on every insertion/deletion, it is typically stored in each node; scapegoat trees are able to calculate it only as needed, which is only when a scapegoat needs to be found.
Unlike most other self-balancing search trees, scapegoat trees are entirely flexible as to their balancing. They support any a such that 0.5 < a < 1. A high a value results in fewer balances, making insertion quicker but lookups and deletions slower, and vice versa for a low a. Therefore in practical applications, an a can be chosen depending on how frequently these actions should be performed.
